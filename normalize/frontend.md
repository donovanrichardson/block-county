### Goal

Create a Python CLI tool using **Inquirer** that gathers the necessary inputs to run a spatial hierarchy–building algorithm and then insert the results back into PostGIS.

---

### Context

You have a database table of hierarchical geometries (e.g., counties → tracts → block groups) stored in PostGIS. Each record belongs to a **hierarchy** and a **level**. You want to interactively choose a record that will act as the **parent** for generating the next level of derived geometries.

You’re building the hierarchy incrementally — going deep into one “family tree” at a time rather than filling out all levels at once.

#### table DDL

```sql
-- DDL generated by Postico 1.5.20
-- Not all database features are supported. Do not use for backup.

-- Table Definition ----------------------------------------------

CREATE TABLE hll (
    id text PRIMARY KEY,
    parent text,
    hierarchy text,
    level numeric(3,0),
    label numeric(3,0),
    geom geometry(MultiPolygon,4269),
    centroid_geom geometry(Point,4269),
    pop numeric(12,0),
    CONSTRAINT hll_hierarchy_level_label_unique UNIQUE (hierarchy, level, label)
);

-- Indices -------------------------------------------------------

CREATE UNIQUE INDEX hll_pkey ON hll(id text_ops);
CREATE INDEX hll_parent_idx ON hll(parent text_ops);
CREATE INDEX hll_hierarchy_idx ON hll(hierarchy text_ops);
CREATE INDEX hll_level_idx ON hll(level numeric_ops);
CREATE INDEX hll_pop_idx ON hll(pop numeric_ops);
CREATE INDEX hll_geom_gix ON hll USING GIST (geom gist_geometry_ops_2d);
CREATE INDEX hll_centroid_geom_gix ON hll USING GIST (centroid_geom gist_geometry_ops_2d);
CREATE UNIQUE INDEX hll_hierarchy_level_label_unique ON hll(hierarchy text_ops,level numeric_ops,label numeric_ops);
CREATE INDEX hll_label_idx ON hll(label numeric_ops);

```

---

### CLI Requirements

#### 1. Input collection

The CLI should:

* Allow the user to **select a hierarchy** (from the database).
* Either:

    * **Enter a leaf record ID manually**, **or**
    * **Drill down interactively**:

        * Start by selecting the hierarchy. `Select id, hierarchy from hll where level = 0`
        * Fetch and display level-0 records (`SELECT * FROM hll WHERE hierarchy = ? AND level = 0`).
        * Allow the user to “go one level deeper” by listing the children of the selected record (`SELECT id FROM table WHERE parent = <this record id>`).
        * Continue until a record with no children.
* Once a leaf record is selected, retrieve its **level** 
* Compute the **new level** as `leaf_level + 1`.
* Ask the user to select a **centroid level** (from a short predefined list, e.g., `county`, `11`, `12`).
  * they correspond to the following geometry:
    * `county` → `counties_2020`
    * `11` → `tracts_2020`
    * `12` → will have to use geometries from `blocks_2020` and aggregate by the first 12 digits of the geoid
  * their geoid fields all correspond to records identified by county_geoid in county_centroids2

At this stage, the CLI will have collected:

* `hierarchy`
* `leaf_id`
* `leaf_level`
* `new_level = parent_level + 1`
* `centroid_level`

---

### 2. Algorithm input and output

* The algorithm takes the chosen **leaf geometry** and **centroid points** (from another table, filtered by the chosen centroid level).
  * we will select the centroid points by doing a postgis within operation. centroid geometries of the chosen centroid level in county_centroids2 that fall within the leaf geometry.
  * the algorithm also takes the K number of clusters, which by default is 19.
* using the cluster_and_insert function in [clustering.py](../clustering.py), we will receive records of the centroid points like so

```py
{
    'geoid': geoid, # the geoid in counties_2020, tracts_2020, or blocks_2020 (first 12 digits of the block geoid if the goid is only 12 digits). This denotes the shape geometreis to be used
    'type': '11', # denotes county (county), tract (11), or block group (12)
    'label': f"r{parent_label}r{labels[i]}", # denotes the LABEL of this feature
    'medioid': geoid in medoid_geoids, #boolean denoting whether this geoid is a medioid
    'pop': pops[i] # the population of the geometry
}
```

* for each label, the ouptut of the algorthm above should then be used to merge the geometries together into children for the hll table:
  - id: autogenerated
  - parent: the leaf_id selected earlier
  - hierarchy: the hierarchy of the leaf record
  - level: new_level
  - label: label as output by the algorithm
  - geom: the merged geometry of all geoms in the appropriate table (counties_2020, tracts_2020, or blocks_2020) which correspond with the all the geoids with the same label, for each label
  - centroid_geom: centroid geometry in county_centroids2 of the 1 record in each label with medioid = true
  - pop: the summed population of all the geoids with the same label for each label

Insert all records into the target table.

### For future implementation

use a geocoder to get an address/ location name for the centroid so that it can be used for a user-friendly way to select leaf geometries in the CLI

---

### 4. Notes / Assumptions

* Hierarchies may have only one root (level 0).
* The user may navigate down through multiple levels before selecting a parent.
* This tool focuses on generating *child levels* for a single branch at a time.
* The geometry merging and population summing occur after the algorithm runs.

